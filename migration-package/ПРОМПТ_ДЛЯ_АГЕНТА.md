# Завдання: Інтегрувати BLOOM Runtime API в цей проєкт

## Контекст

Цей проєкт (NotebookLM Backend) потрібно розширити третім сервісом — BLOOM Runtime API. Це Express/TypeScript сервер, який працює на окремому порту (3002) і забезпечує:

- Worker/task/lease management для розподіленого виконання LLM задач
- Proxy до Membridge Control Plane (admin key ніколи не потрапляє у фронтенд)
- Збереження в PostgreSQL через Drizzle ORM
- MinIO артефакти (використовує вже налаштований MinIO)
- Auto-sync workers з Membridge кожні 10 секунд

## Що потрібно зробити

### 1. Встановити npm пакети

```bash
npm install express express-rate-limit drizzle-orm drizzle-zod drizzle-kit pg minio zod
npm install -D @types/express @types/pg
```

### 2. Створити файлову структуру

Створи директорію `bloom-runtime/` в корені проєкту та скопіюй в неї файли з прикріпленого `BLOOM_RUNTIME_MIGRATION_BUNDLE.md`. Кожен файл в bundle позначений заголовком з шляхом.

Структура:
```
bloom-runtime/
├── server.ts              — точка входу Express сервер
├── db.ts                  — Drizzle ORM підключення
├── schema.ts              — pgTable definitions + types + Zod schemas
├── storage.ts             — DatabaseStorage class
├── routes.ts              — API routes
├── drizzle.config.ts      — Drizzle Kit config
├── middleware/
│   └── runtimeAuth.ts     — X-Runtime-API-Key auth middleware
├── runtime/
│   ├── membridgeClient.ts — HTTP client з retry/backoff
│   ├── workerSync.ts      — Worker auto-sync
│   └── minioArtifacts.ts  — MinIO artifact storage
```

### 3. Створити `bloom-runtime/server.ts`

Це новий файл — точка входу для BLOOM Runtime. Він повинен:
- Створити Express app
- Підключити JSON parser
- Зареєструвати routes
- Слухати порт 3002

```typescript
import express from "express";
import { createServer } from "http";
import { registerRoutes } from "./routes";

const app = express();
const httpServer = createServer(app);

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

(async () => {
  await registerRoutes(httpServer, app);

  app.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    console.error("[bloom-runtime] Error:", err);
    if (!res.headersSent) {
      res.status(status).json({ message });
    }
  });

  const port = parseInt(process.env.BLOOM_RUNTIME_PORT || "3002", 10);
  httpServer.listen({ port, host: "0.0.0.0" }, () => {
    console.log(`[bloom-runtime] serving on port ${port}`);
  });
})();
```

### 4. Адаптувати імпорти

В оригінальному коді використовуються aliased imports:
- `@shared/schema` → замінити на `./schema`
- `./storage` → залишити як є (відносний шлях всередині bloom-runtime/)
- `./db` → залишити як є
- `./runtime/membridgeClient` → залишити
- `./runtime/workerSync` → залишити
- `./runtime/minioArtifacts` → залишити
- `./middleware/runtimeAuth` → залишити

**ВАЖЛИВО:** При копіюванні файлів з bundle замініть всі `@shared/schema` на `./schema` або `../schema` відповідно до розташування файлу.

### 5. Оновити `.replit` workflows

Додай третій workflow для BLOOM Runtime:

```toml
[[workflows.workflow]]
name = "BLOOM Runtime"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npx tsx bloom-runtime/server.ts"
waitForPort = 3002

[workflows.workflow.metadata]
outputType = "console"
```

І додай його до паралельного запуску в Project workflow:

```toml
[[workflows.workflow.tasks]]
task = "workflow.run"
args = "BLOOM Runtime"
```

Додай порт:
```toml
[[ports]]
localPort = 3002
externalPort = 3002
```

### 6. Створити PostgreSQL таблиці

Запусти:
```bash
cd bloom-runtime && npx drizzle-kit push
```

Або використай Drizzle config з bloom-runtime/drizzle.config.ts.

**Альтернатива:** Якщо drizzle-kit не працює з окремої директорії, скопіюй schema.ts та drizzle.config.ts тимчасово в корінь і виконай `npx drizzle-kit push`.

### 7. Перевірка

Запусти сервер та перевір:

```bash
curl http://localhost:3002/api/runtime/health
```

Очікувана відповідь:
```json
{
  "status": "ok",
  "service": "bloom-runtime",
  "uptime": ...,
  "storage": "postgresql",
  "membridge": { "consecutiveFailures": 0, ... }
}
```

## Критичні правила

1. **НЕ чіпай** існуючі файли Python бекенду (app/*)
2. **НЕ чіпай** існуючий Memory Backend (src/*)
3. **НЕ змінюй** порти існуючих сервісів (5000, 3001)
4. Використовуй **той самий** DATABASE_URL що вже є
5. Використовуй **ті самі** MINIO_* змінні що вже є
6. Всі нові файли — тільки в `bloom-runtime/`
