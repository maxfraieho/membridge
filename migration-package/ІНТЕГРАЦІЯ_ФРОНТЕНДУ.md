# Інтеграція фронтенду (garden-seedling) з BLOOM Runtime

## Поточний стан

Фронтенд (garden-seedling / Lovable) зараз працює як окремий static site.
BLOOM Runtime API після міграції буде на порту 3002 в NotebookLM Repl.

## Варіант 1: Proxy через Cloudflare Worker (рекомендовано)

Якщо garden-seedling деплоїться на Cloudflare Pages, додай proxy routes в існуючий Cloudflare Worker:

```javascript
if (url.pathname.startsWith('/api/runtime/') || url.pathname.startsWith('/api/membridge/')) {
  const backendUrl = env.BLOOM_RUNTIME_URL || 'https://notebooklm-repl-url.replit.app:3002';
  const targetUrl = `${backendUrl}${url.pathname}${url.search}`;
  
  return fetch(targetUrl, {
    method: request.method,
    headers: {
      ...Object.fromEntries(request.headers),
      'X-Runtime-API-Key': env.RUNTIME_API_KEY || '',
    },
    body: ['GET', 'HEAD'].includes(request.method) ? null : request.body,
  });
}
```

## Варіант 2: Вказати API URL напряму через env

В garden-seedling додай `.env`:

```
VITE_BLOOM_RUNTIME_URL=https://notebooklm-repl-url.replit.app
```

І в `mcpGatewayClient.ts` (або де робляться API виклики) використай:

```typescript
const RUNTIME_BASE = import.meta.env.VITE_BLOOM_RUNTIME_URL || '';

export async function runtimeFetch(path: string, init?: RequestInit) {
  return fetch(`${RUNTIME_BASE}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...init?.headers,
    },
  });
}
```

## Варіант 3: Підключити BLOOM Runtime UI прямо в garden-seedling

Скопіюй ці файли з цього Repl в garden-seedling:

1. `client/src/pages/RuntimeSettings.tsx` → `src/pages/RuntimeSettings.tsx`
2. `client/src/pages/MembridgePage.tsx` → `src/pages/MembridgePage.tsx`

Адаптуй імпорти:
- `@/components/ui/*` → залежить від shadcn setup в garden-seedling
- `@shared/schema` → типи можна скопіювати як інтерфейси в окремий файл `src/lib/bloom-types.ts`
- `@/lib/queryClient` → якщо є TanStack Query, використай існуючий queryClient

Додай маршрути:
```tsx
<Route path="/runtime" component={RuntimeSettings} />
<Route path="/membridge" component={MembridgePage} />
```

## TypeScript типи для фронтенду

Якщо фронтенд не має Drizzle, створи файл з чистими TypeScript інтерфейсами:

```typescript
// src/lib/bloom-types.ts

export type WorkerStatus = "online" | "offline" | "syncing" | "error" | "unknown";
export type TaskStatus = "queued" | "leased" | "running" | "completed" | "failed" | "dead";
export type LeaseStatus = "active" | "expired" | "released" | "failed";

export interface WorkerCapability {
  claude_cli: boolean;
  max_concurrency: number;
  labels: string[];
}

export interface WorkerNode {
  id: string;
  node_id: string;
  url: string;
  status: WorkerStatus;
  capabilities: WorkerCapability;
  last_heartbeat: number | null;
  ip_addrs: string[];
  obs_count: number;
  db_sha: string;
  registered_at: number;
  active_leases: number;
}

export interface Lease {
  id: string;
  task_id: string;
  worker_id: string;
  started_at: number;
  expires_at: number;
  ttl_seconds: number;
  status: LeaseStatus;
  last_heartbeat: number;
  context_id: string | null;
}

export interface LLMTask {
  id: string;
  context_id: string;
  agent_slug: string;
  prompt: string;
  context_hints: string[];
  policy: { timeout_sec: number; budget: number };
  desired_format: "json" | "text";
  status: TaskStatus;
  created_at: number;
  updated_at: number;
  lease_id: string | null;
  worker_id: string | null;
  attempts: number;
  max_attempts: number;
}

export interface RuntimeConfig {
  membridge_server_url: string;
  admin_key_masked: string;
  connected: boolean;
  last_test: number | null;
}
```
