---
tags:
  - domain:runtime
  - status:canonical
  - format:spec
  - feature:membridge-proxy
created: 2026-02-24
updated: 2026-02-24
tier: 1
title: "Integration: Membridge Claude CLI Proxy"
dg-publish: true
---

# Integration: Membridge Claude CLI Proxy

> Created: 2026-02-24
> Author: architect
> Status: canonical
> Language: English (canonical)

---

## 0. Purpose

This document specifies how the BLOOM Runtime delegates LLM execution to Membridge worker nodes via the Claude CLI Proxy pattern. It defines the roles, envelope formats, lease lifecycle, security boundaries, worker invocation protocol, and context loading rules.

**Key principle:** The BLOOM Runtime orchestrator never executes LLM prompts directly. Instead, it creates LLM-task envelopes and delegates execution to Membridge workers that run Claude CLI locally.

---

## 1. Roles

### 1.1 BLOOM Runtime (Orchestrator / Proxy)

- Accepts LLM-task requests from the frontend or internal pipeline
- Creates task envelopes with context, policy, and desired format
- Routes tasks to available workers using capability-based selection
- Manages lease lifecycle (create, heartbeat, expire, failover)
- Collects results and creates immutable artifacts
- Never executes Claude CLI directly

### 1.2 Membridge Server (Control Plane)

- Maintains registry of worker nodes via heartbeat protocol
- Provides `/agents` and `/projects` endpoints for worker discovery
- Manages leadership leases for memory sync (independent of task leasing)
- Serves as the source of truth for worker availability

### 1.3 Membridge Worker (Edge Node)

- Runs `membridge-agent` on port 8001
- Executes Claude CLI with the provided prompt and context
- Sends heartbeats to confirm liveness during execution
- Returns structured results (output or error) to the orchestrator
- Never writes directly to canonical storage (MinIO)

### 1.4 Authority Boundaries

| Component | LLM Execution | Task Queue | Artifact Store | Canonical Storage |
|-----------|:---:|:---:|:---:|:---:|
| BLOOM Runtime | Delegates | Read/Write | Write (new) | Read only |
| Membridge Server | None | None | Registry | Metadata only |
| Membridge Worker | Executes | Heartbeat | None | Read (local) |

**Axiom:** Workers never write directly to canonical storage. All mutations flow through the BLOOM Runtime after explicit consent.

---

## 2. LLM-Task Envelope

The task envelope is the unit of work delegated to a worker.

### 2.1 Task Structure

```typescript
interface LLMTask {
  id: string;                   // UUID, generated by orchestrator
  context_id: string;           // Execution context identifier
  agent_slug: string;           // Agent definition to use
  prompt: string;               // The LLM prompt text
  context_hints: string[];      // Files/paths to load as context
  policy: {
    timeout_sec: number;        // Max execution time (1-3600s)
    budget: number;             // Token budget (0 = unlimited)
  };
  desired_format: "json" | "text";  // Expected output format
  status: TaskStatus;           // queued | leased | running | completed | failed | dead
  created_at: number;           // Unix timestamp
  updated_at: number;           // Unix timestamp
  lease_id: string | null;      // Active lease ID
  worker_id: string | null;     // Assigned worker
  attempts: number;             // Current attempt count
  max_attempts: number;         // Max retry attempts (1-10, default: 3)
}
```

### 2.2 Task Status State Machine

```
                    ┌──────────┐
                    │  QUEUED   │
                    └────┬─────┘
                         │ lease assigned
                    ┌────▼─────┐
              ┌─────│  LEASED  │─────┐
              │     └────┬─────┘     │
              │          │ worker    │ lease expired
              │          │ starts   │ (no heartbeat)
              │     ┌────▼─────┐     │
              │     │ RUNNING  │     │
              │     └────┬─────┘     │
              │       ┌──┴──┐        │
              │  ┌────▼┐  ┌▼─────┐   │
              │  │DONE │  │FAILED│   │
              │  └─────┘  └──┬───┘   │
              │              │       │
              │         attempts     │
              │         < max?       │
              │        YES │ NO      │
              │    ┌───▼─┐ │        │
              │    │QUEUED│ ▼        ▼
              │    └─────┘ ┌────────────┐
              └───────────►│    DEAD    │
                           └────────────┘
```

| Transition | Trigger | Action |
|-----------|---------|--------|
| queued → leased | Worker assigned via lease | Set lease_id, worker_id |
| leased → running | Worker confirms execution started | Update status |
| running → completed | Worker submits result (success) | Create artifact |
| running → failed | Worker submits error or timeout | Increment attempts |
| failed → queued | attempts < max_attempts | Re-enqueue for retry |
| failed → dead | attempts >= max_attempts | Terminal state |
| leased → queued | Lease expired (no heartbeat) | Release lease, re-enqueue |

---

## 3. Result Envelope

The result envelope is returned by the worker upon task completion.

```typescript
interface LLMResult {
  id: string;                   // UUID
  task_id: string;              // References the original task
  worker_id: string;            // Worker that executed the task
  artifact_id: string;          // Created artifact ID
  status: "success" | "error";
  output: string | null;        // LLM output (if success)
  error_message: string | null; // Error details (if error)
  metrics: {
    duration_ms: number;        // Execution duration
    tokens_used?: number;       // Token consumption (if available)
  };
  completed_at: number;         // Unix timestamp
}
```

### 3.1 Result Validation

The orchestrator validates results before creating artifacts:
1. `task_id` must reference an existing task in `running` or `leased` status
2. `worker_id` must match the worker assigned via the active lease
3. `metrics.duration_ms` must be non-negative
4. If `status === "success"`, `output` must not be null
5. If `status === "error"`, `error_message` must not be null

---

## 4. Lease Lifecycle

Leases bind a task to a worker for a bounded duration.

### 4.1 Lease Structure

```typescript
interface Lease {
  id: string;                   // UUID
  task_id: string;              // Bound task
  worker_id: string;            // Assigned worker
  started_at: number;           // Unix timestamp
  expires_at: number;           // started_at + ttl_seconds
  ttl_seconds: number;          // Default: policy.timeout_sec + 30
  status: LeaseStatus;          // active | expired | released | failed
  last_heartbeat: number;       // Last heartbeat Unix timestamp
  context_id: string | null;    // For sticky routing
}
```

### 4.2 Lease State Machine

```
  ┌─────────┐
  │  ACTIVE  │◄──── created (task assigned to worker)
  └────┬─────┘
       │
  ┌────┴────────────────────┐
  │                         │
  ▼                         ▼
heartbeat received    no heartbeat within TTL
  │                         │
  ▼                         ▼
[ACTIVE]              ┌──────────┐
(renew)               │ EXPIRED  │
                      └────┬─────┘
                           │
                    task re-enqueued
                    or marked dead
```

| Status | Meaning |
|--------|---------|
| `active` | Worker is executing; heartbeats received |
| `expired` | TTL elapsed without heartbeat; task will be re-enqueued |
| `released` | Worker completed task; lease explicitly released |
| `failed` | Worker reported failure; lease terminated |

### 4.3 Heartbeat Protocol

- Workers send heartbeats every `heartbeat_interval` seconds (recommended: 10s)
- Heartbeat updates `last_heartbeat` and extends lease validity
- If `now > expires_at` and no heartbeat received, lease transitions to `expired`
- Expired leases trigger task failover (re-enqueue if attempts remain)

### 4.4 Failover Flow

```
1. Background reaper checks leases every 15 seconds
2. For each lease where now > expires_at:
   a. Set lease.status = "expired"
   b. If task.attempts < task.max_attempts:
      - Set task.status = "queued"
      - Clear task.lease_id and task.worker_id
      - Increment task.attempts
   c. Else:
      - Set task.status = "dead"
   d. Write audit log entry
```

---

## 5. Security Boundaries

### 5.1 Network Trust Zones

```
┌─────────────────────────────────────────────────┐
│  BLOOM Runtime (Replit)                         │
│  ┌──────────────┐    ┌───────────────────────┐  │
│  │ Express API  │    │ In-Memory Task Store  │  │
│  │ /api/runtime │    │ tasks, leases, audit  │  │
│  └──────┬───────┘    └───────────────────────┘  │
│         │                                        │
│         │ HTTPS + X-MEMBRIDGE-ADMIN              │
└─────────┼────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────┐
│  Membridge Control Plane (Alpine :8000)         │
│  ┌──────────────┐    ┌──────────────────────┐   │
│  │ /agents      │    │ Worker Registry      │   │
│  │ /projects    │    │ (in-memory)          │   │
│  └──────────────┘    └──────────────────────┘   │
└─────────────────────────────────────────────────┘
          │
          │ Internal network (LAN)
          ▼
┌─────────────────────────────────────────────────┐
│  Membridge Worker (Edge node :8001)             │
│  ┌──────────────┐    ┌──────────────────────┐   │
│  │ Claude CLI   │    │ Local claude-mem.db  │   │
│  │ execution    │    │ (session memory)     │   │
│  └──────────────┘    └──────────────────────┘   │
└─────────────────────────────────────────────────┘
```

### 5.2 Authentication

| Boundary | Mechanism | Header |
|----------|-----------|--------|
| Frontend → BLOOM Runtime | Session-based | Standard HTTP |
| BLOOM Runtime → Membridge Server | Admin key | `X-MEMBRIDGE-ADMIN` |
| Worker → Membridge Server | Admin key | `X-MEMBRIDGE-ADMIN` |
| Local processes → Agent | Exempt | Localhost only |
| Remote → Agent | Agent key | `X-MEMBRIDGE-AGENT` |

### 5.3 Data Isolation

| Data Type | Storage | Who Writes | Who Reads |
|-----------|---------|------------|-----------|
| LLM tasks | BLOOM Runtime (in-memory) | Runtime API | Runtime API, Frontend |
| Leases | BLOOM Runtime (in-memory) | Runtime API | Runtime API, Frontend |
| Artifacts | BLOOM Runtime (in-memory) | Runtime API on completion | Frontend |
| claude-mem.db | MinIO (via Membridge) | Workers via hooks | Workers |
| DiffMem/git | git repository | Apply Engine | Agents |

**Axiom A2 (inherited):** Two memory types (claude-mem.db and DiffMem/git) must never mix. Workers read/write claude-mem.db via Membridge sync. Agent reasoning memory uses git-based DiffMem exclusively.

---

## 6. Worker Claude CLI Invocation

### 6.1 Invocation Flow

When a worker receives a leased task, it executes the following sequence:

```
1. Receive task envelope from orchestrator
2. Validate task fields (agent_slug, prompt, context_hints)
3. Prepare Claude CLI arguments:
   a. Set agent context from agent_slug
   b. Load context files from context_hints
   c. Set output format from desired_format
   d. Set timeout from policy.timeout_sec
4. Execute: claude --agent <agent_slug> --prompt <prompt>
5. Start heartbeat loop (every 10s → POST /heartbeat)
6. Wait for Claude CLI completion or timeout
7. Parse output according to desired_format
8. Submit result envelope to orchestrator
9. Release lease
```

### 6.2 Timeout Handling

- Worker sets a local alarm at `policy.timeout_sec`
- If Claude CLI exceeds timeout, worker kills the process
- Worker submits an error result with `error_message: "timeout exceeded"`
- Lease transitions to `failed`

### 6.3 Error Handling

| Error Type | Worker Action | Orchestrator Action |
|-----------|---------------|---------------------|
| Claude CLI exit code != 0 | Submit error result | Increment attempts, retry or mark dead |
| Network timeout to orchestrator | Retry submission 3x | Lease expires, task re-enqueued |
| Invalid prompt / context | Submit error result | Mark failed immediately |
| Worker crash | No action (dead) | Lease expires via TTL, task re-enqueued |

---

## 7. Context Loading Rules

### 7.1 Context Assembly

The `context_hints` field in the task envelope specifies which files or paths the worker should load as context for the Claude CLI invocation.

| Hint Format | Example | Resolution |
|------------|---------|------------|
| Relative path | `src/agents/writer.md` | Resolve relative to project root |
| Glob pattern | `docs/*.md` | Expand to matching files |
| Agent reference | `@agent/writer` | Load agent definition from registry |
| Memory reference | `@memory/recent` | Load recent DiffMem entries (read-only) |

### 7.2 Context Size Limits

- Maximum total context: determined by `policy.budget` (token limit)
- If context exceeds budget, worker truncates oldest entries first
- Context loading failures are non-fatal: worker proceeds with available context

### 7.3 Context Isolation Rules

1. Workers load context from their local filesystem (synced via Membridge)
2. Workers never access other workers' local state
3. Workers never write to shared context during execution
4. All context mutations happen post-execution through the Proposal system

---

## 8. Capability-Based Routing

### 8.1 Worker Selection Algorithm

When the orchestrator needs to assign a task to a worker:

```
1. Fetch online workers from Membridge (GET /agents + /projects)
2. Filter by capability:
   a. worker.capabilities.claude_cli === true
   b. worker.active_leases < worker.capabilities.max_concurrency
3. Apply sticky routing:
   a. If task.context_id matches a worker's existing lease.context_id
   b. Prefer that worker (reduces context reload overhead)
4. If multiple candidates remain:
   a. Sort by health (most recent heartbeat first)
   b. Sort by load (fewest active leases first)
5. Select top candidate
6. If no candidates: task remains queued
```

### 8.2 Worker Capability Structure

```typescript
interface WorkerCapability {
  claude_cli: boolean;        // Can execute Claude CLI
  max_concurrency: number;    // Max simultaneous tasks
  labels: string[];           // Custom labels (e.g., "gpu", "arm64")
}
```

---

## 9. API Surface (BLOOM Runtime)

| Method | Path | Description |
|--------|------|-------------|
| `GET` | `/api/runtime/workers` | List workers (merged from Membridge) |
| `GET` | `/api/runtime/workers/:id` | Worker details + active leases |
| `POST` | `/api/runtime/llm-tasks` | Create new LLM task |
| `POST` | `/api/runtime/llm-tasks/:id/lease` | Assign task to worker (create lease) |
| `POST` | `/api/runtime/llm-tasks/:id/heartbeat` | Worker heartbeat for active lease |
| `POST` | `/api/runtime/llm-tasks/:id/complete` | Submit result + create artifact |
| `GET` | `/api/runtime/leases` | List active leases |
| `GET` | `/api/runtime/runs` | Recent task executions |
| `GET` | `/api/runtime/artifacts` | Artifacts by task_id |
| `GET` | `/api/runtime/config` | Get proxy configuration |
| `POST` | `/api/runtime/config` | Save proxy configuration |
| `POST` | `/api/runtime/test-connection` | Test Membridge connectivity |

---

## Semantic Relations

**This document is part of:**
- [[docs/architecture/runtime/]] -- Runtime architecture package

**Depends on:**
- [[АРХІТЕКТУРНИЙ_КОРІНЬ]] -- Axioms A1-A7, authority boundaries
- [[ІНТЕГРАЦІЯ_MEMBRIDGE]] -- Membridge Control Plane contract
- [[JOB_QUEUE_ТА_ARTIFACT_MODEL]] -- Task state machines, artifact model
- [[КАНОНІЧНА_МОДЕЛЬ_АВТОРИТЕТУ_СХОВИЩА]] -- Write/read authority matrix

**Referenced by:**
- [[docs/ІНДЕКС.md]] -- Master documentation index
- [[docs/audit/_INDEX.md]] -- Audit documentation package
